// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: telemetry.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const acknowledgeAlert = `-- name: AcknowledgeAlert :exec
UPDATE performance_alerts 
SET acknowledged = TRUE, acknowledged_by = ?, acknowledged_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type AcknowledgeAlertParams struct {
	AcknowledgedBy sql.NullString `json:"acknowledged_by"`
	ID             int64          `json:"id"`
}

// Acknowledge an alert
func (q *Queries) AcknowledgeAlert(ctx context.Context, arg AcknowledgeAlertParams) error {
	_, err := q.exec(ctx, q.acknowledgeAlertStmt, acknowledgeAlert, arg.AcknowledgedBy, arg.ID)
	return err
}

const cleanOldMetrics = `-- name: CleanOldMetrics :exec
DELETE FROM metrics_data 
WHERE timestamp < ?
`

// Delete old metric data points based on retention period
func (q *Queries) CleanOldMetrics(ctx context.Context, timestamp time.Time) error {
	_, err := q.exec(ctx, q.cleanOldMetricsStmt, cleanOldMetrics, timestamp)
	return err
}

const countActiveAlertsBySeverity = `-- name: CountActiveAlertsBySeverity :many
SELECT 
    severity, COUNT(*) as alert_count
FROM performance_alerts 
WHERE resolved = FALSE
GROUP BY severity
ORDER BY 
    CASE severity
        WHEN 'critical' THEN 1
        WHEN 'high' THEN 2
        WHEN 'medium' THEN 3
        WHEN 'low' THEN 4
    END
`

type CountActiveAlertsBySeverityRow struct {
	Severity   string `json:"severity"`
	AlertCount int64  `json:"alert_count"`
}

// Count active alerts by severity level
func (q *Queries) CountActiveAlertsBySeverity(ctx context.Context) ([]CountActiveAlertsBySeverityRow, error) {
	rows, err := q.query(ctx, q.countActiveAlertsBySeverityStmt, countActiveAlertsBySeverity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountActiveAlertsBySeverityRow{}
	for rows.Next() {
		var i CountActiveAlertsBySeverityRow
		if err := rows.Scan(&i.Severity, &i.AlertCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveAlerts = `-- name: GetActiveAlerts :many
SELECT 
    id, alert_type, metric_name, current_value, threshold_value, severity,
    message, component, session_id, acknowledged, acknowledged_by, acknowledged_at,
    resolved, resolved_at, created_at
FROM performance_alerts 
WHERE resolved = FALSE
ORDER BY severity, created_at DESC
`

// Get all active (unresolved) alerts
func (q *Queries) GetActiveAlerts(ctx context.Context) ([]PerformanceAlert, error) {
	rows, err := q.query(ctx, q.getActiveAlertsStmt, getActiveAlerts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PerformanceAlert{}
	for rows.Next() {
		var i PerformanceAlert
		if err := rows.Scan(
			&i.ID,
			&i.AlertType,
			&i.MetricName,
			&i.CurrentValue,
			&i.ThresholdValue,
			&i.Severity,
			&i.Message,
			&i.Component,
			&i.SessionID,
			&i.Acknowledged,
			&i.AcknowledgedBy,
			&i.AcknowledgedAt,
			&i.Resolved,
			&i.ResolvedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveAlertsByComponent = `-- name: GetActiveAlertsByComponent :many
SELECT 
    id, alert_type, metric_name, current_value, threshold_value, severity,
    message, component, session_id, acknowledged, acknowledged_by, acknowledged_at,
    resolved, resolved_at, created_at
FROM performance_alerts 
WHERE component = ? AND resolved = FALSE
ORDER BY severity, created_at DESC
`

// Get active alerts for a specific component
func (q *Queries) GetActiveAlertsByComponent(ctx context.Context, component sql.NullString) ([]PerformanceAlert, error) {
	rows, err := q.query(ctx, q.getActiveAlertsByComponentStmt, getActiveAlertsByComponent, component)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PerformanceAlert{}
	for rows.Next() {
		var i PerformanceAlert
		if err := rows.Scan(
			&i.ID,
			&i.AlertType,
			&i.MetricName,
			&i.CurrentValue,
			&i.ThresholdValue,
			&i.Severity,
			&i.Message,
			&i.Component,
			&i.SessionID,
			&i.Acknowledged,
			&i.AcknowledgedBy,
			&i.AcknowledgedAt,
			&i.Resolved,
			&i.ResolvedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAlertHistory = `-- name: GetAlertHistory :many
SELECT 
    id, alert_type, metric_name, current_value, threshold_value, severity,
    message, component, session_id, acknowledged, acknowledged_by, acknowledged_at,
    resolved, resolved_at, created_at
FROM performance_alerts 
WHERE metric_name = ?
ORDER BY created_at DESC
LIMIT ?
`

type GetAlertHistoryParams struct {
	MetricName string `json:"metric_name"`
	Limit      int64  `json:"limit"`
}

// Get alert history for a metric
func (q *Queries) GetAlertHistory(ctx context.Context, arg GetAlertHistoryParams) ([]PerformanceAlert, error) {
	rows, err := q.query(ctx, q.getAlertHistoryStmt, getAlertHistory, arg.MetricName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PerformanceAlert{}
	for rows.Next() {
		var i PerformanceAlert
		if err := rows.Scan(
			&i.ID,
			&i.AlertType,
			&i.MetricName,
			&i.CurrentValue,
			&i.ThresholdValue,
			&i.Severity,
			&i.Message,
			&i.Component,
			&i.SessionID,
			&i.Acknowledged,
			&i.AcknowledgedBy,
			&i.AcknowledgedAt,
			&i.Resolved,
			&i.ResolvedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAlertsFromView = `-- name: GetAlertsFromView :many
SELECT 
    alert_type, metric_name, current_value, threshold_value, severity,
    message, component, session_id, created_at, severity_priority
FROM active_alerts
`

// Get active alerts using the view
func (q *Queries) GetAlertsFromView(ctx context.Context) ([]ActiveAlert, error) {
	rows, err := q.query(ctx, q.getAlertsFromViewStmt, getAlertsFromView)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActiveAlert{}
	for rows.Next() {
		var i ActiveAlert
		if err := rows.Scan(
			&i.AlertType,
			&i.MetricName,
			&i.CurrentValue,
			&i.ThresholdValue,
			&i.Severity,
			&i.Message,
			&i.Component,
			&i.SessionID,
			&i.CreatedAt,
			&i.SeverityPriority,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllMetricMetadata = `-- name: GetAllMetricMetadata :many
SELECT 
    id, metric_name, metric_type, description, unit, component, 
    enabled, retention_days, created_at, updated_at
FROM metrics_metadata 
WHERE enabled = TRUE
ORDER BY component, metric_name
`

// Get all metric metadata
func (q *Queries) GetAllMetricMetadata(ctx context.Context) ([]MetricsMetadatum, error) {
	rows, err := q.query(ctx, q.getAllMetricMetadataStmt, getAllMetricMetadata)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MetricsMetadatum{}
	for rows.Next() {
		var i MetricsMetadatum
		if err := rows.Scan(
			&i.ID,
			&i.MetricName,
			&i.MetricType,
			&i.Description,
			&i.Unit,
			&i.Component,
			&i.Enabled,
			&i.RetentionDays,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPerformanceBenchmarks = `-- name: GetAllPerformanceBenchmarks :many
SELECT 
    id, metric_name, target_value, threshold_warning, threshold_critical,
    unit, description, active, created_at, updated_at
FROM performance_benchmarks 
WHERE active = TRUE
ORDER BY metric_name
`

// Get all active performance benchmarks
func (q *Queries) GetAllPerformanceBenchmarks(ctx context.Context) ([]PerformanceBenchmark, error) {
	rows, err := q.query(ctx, q.getAllPerformanceBenchmarksStmt, getAllPerformanceBenchmarks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PerformanceBenchmark{}
	for rows.Next() {
		var i PerformanceBenchmark
		if err := rows.Scan(
			&i.ID,
			&i.MetricName,
			&i.TargetValue,
			&i.ThresholdWarning,
			&i.ThresholdCritical,
			&i.Unit,
			&i.Description,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getComponentHealth = `-- name: GetComponentHealth :one
SELECT 
    id, component, status, details, last_check, created_at, updated_at
FROM system_health 
WHERE component = ?
ORDER BY last_check DESC 
LIMIT 1
`

// Get health status for a specific component
func (q *Queries) GetComponentHealth(ctx context.Context, component string) (SystemHealth, error) {
	row := q.queryRow(ctx, q.getComponentHealthStmt, getComponentHealth, component)
	var i SystemHealth
	err := row.Scan(
		&i.ID,
		&i.Component,
		&i.Status,
		&i.Details,
		&i.LastCheck,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getComponentMetricsSummary = `-- name: GetComponentMetricsSummary :many
SELECT 
    metric_name, metric_type, unit,
    COUNT(*) as data_points,
    AVG(value) as avg_value,
    MIN(value) as min_value,
    MAX(value) as max_value,
    MAX(timestamp) as last_updated
FROM metrics_data 
WHERE component = ?
  AND timestamp >= ?
GROUP BY metric_name, metric_type, unit
ORDER BY metric_name
`

type GetComponentMetricsSummaryParams struct {
	Component sql.NullString `json:"component"`
	Timestamp time.Time      `json:"timestamp"`
}

type GetComponentMetricsSummaryRow struct {
	MetricName  string          `json:"metric_name"`
	MetricType  string          `json:"metric_type"`
	Unit        sql.NullString  `json:"unit"`
	DataPoints  int64           `json:"data_points"`
	AvgValue    sql.NullFloat64 `json:"avg_value"`
	MinValue    interface{}     `json:"min_value"`
	MaxValue    interface{}     `json:"max_value"`
	LastUpdated interface{}     `json:"last_updated"`
}

// Get metrics summary for a specific component
func (q *Queries) GetComponentMetricsSummary(ctx context.Context, arg GetComponentMetricsSummaryParams) ([]GetComponentMetricsSummaryRow, error) {
	rows, err := q.query(ctx, q.getComponentMetricsSummaryStmt, getComponentMetricsSummary, arg.Component, arg.Timestamp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetComponentMetricsSummaryRow{}
	for rows.Next() {
		var i GetComponentMetricsSummaryRow
		if err := rows.Scan(
			&i.MetricName,
			&i.MetricType,
			&i.Unit,
			&i.DataPoints,
			&i.AvgValue,
			&i.MinValue,
			&i.MaxValue,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatabaseSize = `-- name: GetDatabaseSize :one
SELECT 
    (SELECT COUNT(*) FROM metrics_data) as total_metrics,
    (SELECT COUNT(*) FROM performance_alerts) as total_alerts,
    (SELECT COUNT(*) FROM system_health) as health_components,
    (SELECT COUNT(DISTINCT component) FROM metrics_data) as unique_components,
    (SELECT COUNT(DISTINCT metric_name) FROM metrics_data) as unique_metrics
`

type GetDatabaseSizeRow struct {
	TotalMetrics     int64 `json:"total_metrics"`
	TotalAlerts      int64 `json:"total_alerts"`
	HealthComponents int64 `json:"health_components"`
	UniqueComponents int64 `json:"unique_components"`
	UniqueMetrics    int64 `json:"unique_metrics"`
}

// Get current database size statistics
func (q *Queries) GetDatabaseSize(ctx context.Context) (GetDatabaseSizeRow, error) {
	row := q.queryRow(ctx, q.getDatabaseSizeStmt, getDatabaseSize)
	var i GetDatabaseSizeRow
	err := row.Scan(
		&i.TotalMetrics,
		&i.TotalAlerts,
		&i.HealthComponents,
		&i.UniqueComponents,
		&i.UniqueMetrics,
	)
	return i, err
}

const getMetricData = `-- name: GetMetricData :many
SELECT 
    id, metric_name, metric_type, value, unit, session_id, component, tags, timestamp, created_at
FROM metrics_data 
WHERE metric_name = ?
  AND timestamp >= ? 
  AND timestamp <= ?
ORDER BY timestamp DESC
LIMIT ?
`

type GetMetricDataParams struct {
	MetricName  string    `json:"metric_name"`
	Timestamp   time.Time `json:"timestamp"`
	Timestamp_2 time.Time `json:"timestamp_2"`
	Limit       int64     `json:"limit"`
}

// Get metric data points for a specific metric within time range
func (q *Queries) GetMetricData(ctx context.Context, arg GetMetricDataParams) ([]MetricsDatum, error) {
	rows, err := q.query(ctx, q.getMetricDataStmt, getMetricData,
		arg.MetricName,
		arg.Timestamp,
		arg.Timestamp_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MetricsDatum{}
	for rows.Next() {
		var i MetricsDatum
		if err := rows.Scan(
			&i.ID,
			&i.MetricName,
			&i.MetricType,
			&i.Value,
			&i.Unit,
			&i.SessionID,
			&i.Component,
			&i.Tags,
			&i.Timestamp,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetricDataByComponent = `-- name: GetMetricDataByComponent :many
SELECT 
    id, metric_name, metric_type, value, unit, session_id, component, tags, timestamp, created_at
FROM metrics_data 
WHERE component = ?
  AND timestamp >= ? 
  AND timestamp <= ?
ORDER BY timestamp DESC
LIMIT ?
`

type GetMetricDataByComponentParams struct {
	Component   sql.NullString `json:"component"`
	Timestamp   time.Time      `json:"timestamp"`
	Timestamp_2 time.Time      `json:"timestamp_2"`
	Limit       int64          `json:"limit"`
}

// Get metric data points for a specific component within time range
func (q *Queries) GetMetricDataByComponent(ctx context.Context, arg GetMetricDataByComponentParams) ([]MetricsDatum, error) {
	rows, err := q.query(ctx, q.getMetricDataByComponentStmt, getMetricDataByComponent,
		arg.Component,
		arg.Timestamp,
		arg.Timestamp_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MetricsDatum{}
	for rows.Next() {
		var i MetricsDatum
		if err := rows.Scan(
			&i.ID,
			&i.MetricName,
			&i.MetricType,
			&i.Value,
			&i.Unit,
			&i.SessionID,
			&i.Component,
			&i.Tags,
			&i.Timestamp,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetricMetadata = `-- name: GetMetricMetadata :one
SELECT 
    id, metric_name, metric_type, description, unit, component, 
    enabled, retention_days, created_at, updated_at
FROM metrics_metadata 
WHERE metric_name = ?
`

// Get metadata for a specific metric
func (q *Queries) GetMetricMetadata(ctx context.Context, metricName string) (MetricsMetadatum, error) {
	row := q.queryRow(ctx, q.getMetricMetadataStmt, getMetricMetadata, metricName)
	var i MetricsMetadatum
	err := row.Scan(
		&i.ID,
		&i.MetricName,
		&i.MetricType,
		&i.Description,
		&i.Unit,
		&i.Component,
		&i.Enabled,
		&i.RetentionDays,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMetricStatistics = `-- name: GetMetricStatistics :one
SELECT 
    COUNT(*) as data_points,
    AVG(value) as avg_value,
    MIN(value) as min_value,
    MAX(value) as max_value,
    MIN(timestamp) as first_recorded,
    MAX(timestamp) as last_recorded
FROM metrics_data 
WHERE metric_name = ?
  AND timestamp >= ? 
  AND timestamp <= ?
`

type GetMetricStatisticsParams struct {
	MetricName  string    `json:"metric_name"`
	Timestamp   time.Time `json:"timestamp"`
	Timestamp_2 time.Time `json:"timestamp_2"`
}

type GetMetricStatisticsRow struct {
	DataPoints    int64           `json:"data_points"`
	AvgValue      sql.NullFloat64 `json:"avg_value"`
	MinValue      interface{}     `json:"min_value"`
	MaxValue      interface{}     `json:"max_value"`
	FirstRecorded interface{}     `json:"first_recorded"`
	LastRecorded  interface{}     `json:"last_recorded"`
}

// Get statistics for a specific metric over time period
func (q *Queries) GetMetricStatistics(ctx context.Context, arg GetMetricStatisticsParams) (GetMetricStatisticsRow, error) {
	row := q.queryRow(ctx, q.getMetricStatisticsStmt, getMetricStatistics, arg.MetricName, arg.Timestamp, arg.Timestamp_2)
	var i GetMetricStatisticsRow
	err := row.Scan(
		&i.DataPoints,
		&i.AvgValue,
		&i.MinValue,
		&i.MaxValue,
		&i.FirstRecorded,
		&i.LastRecorded,
	)
	return i, err
}

const getMetricsSummary = `-- name: GetMetricsSummary :many
SELECT 
    metric_name, metric_type, unit, component, data_points, 
    avg_value, min_value, max_value, last_updated
FROM recent_metrics_summary
`

// Get metrics summary from the view
func (q *Queries) GetMetricsSummary(ctx context.Context) ([]RecentMetricsSummary, error) {
	rows, err := q.query(ctx, q.getMetricsSummaryStmt, getMetricsSummary)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecentMetricsSummary{}
	for rows.Next() {
		var i RecentMetricsSummary
		if err := rows.Scan(
			&i.MetricName,
			&i.MetricType,
			&i.Unit,
			&i.Component,
			&i.DataPoints,
			&i.AvgValue,
			&i.MinValue,
			&i.MaxValue,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPerformanceBenchmark = `-- name: GetPerformanceBenchmark :one
SELECT 
    id, metric_name, target_value, threshold_warning, threshold_critical,
    unit, description, active, created_at, updated_at
FROM performance_benchmarks 
WHERE metric_name = ? AND active = TRUE
`

// Get performance benchmark for a metric
func (q *Queries) GetPerformanceBenchmark(ctx context.Context, metricName string) (PerformanceBenchmark, error) {
	row := q.queryRow(ctx, q.getPerformanceBenchmarkStmt, getPerformanceBenchmark, metricName)
	var i PerformanceBenchmark
	err := row.Scan(
		&i.ID,
		&i.MetricName,
		&i.TargetValue,
		&i.ThresholdWarning,
		&i.ThresholdCritical,
		&i.Unit,
		&i.Description,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRecentMetricsForSession = `-- name: GetRecentMetricsForSession :many
SELECT 
    id, metric_name, metric_type, value, unit, session_id, component, tags, timestamp, created_at
FROM metrics_data 
WHERE session_id = ?
  AND timestamp >= ?
ORDER BY timestamp DESC
LIMIT ?
`

type GetRecentMetricsForSessionParams struct {
	SessionID sql.NullString `json:"session_id"`
	Timestamp time.Time      `json:"timestamp"`
	Limit     int64          `json:"limit"`
}

// Get recent metrics for a specific session
func (q *Queries) GetRecentMetricsForSession(ctx context.Context, arg GetRecentMetricsForSessionParams) ([]MetricsDatum, error) {
	rows, err := q.query(ctx, q.getRecentMetricsForSessionStmt, getRecentMetricsForSession, arg.SessionID, arg.Timestamp, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MetricsDatum{}
	for rows.Next() {
		var i MetricsDatum
		if err := rows.Scan(
			&i.ID,
			&i.MetricName,
			&i.MetricType,
			&i.Value,
			&i.Unit,
			&i.SessionID,
			&i.Component,
			&i.Tags,
			&i.Timestamp,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSystemHealth = `-- name: GetSystemHealth :many
SELECT 
    id, component, status, details, last_check, created_at, updated_at
FROM system_health 
WHERE last_check > ?
ORDER BY component
`

// Get current system health for all components
func (q *Queries) GetSystemHealth(ctx context.Context, lastCheck time.Time) ([]SystemHealth, error) {
	rows, err := q.query(ctx, q.getSystemHealthStmt, getSystemHealth, lastCheck)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SystemHealth{}
	for rows.Next() {
		var i SystemHealth
		if err := rows.Scan(
			&i.ID,
			&i.Component,
			&i.Status,
			&i.Details,
			&i.LastCheck,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSystemHealthOverview = `-- name: GetSystemHealthOverview :many
SELECT 
    component, status, details, last_check, status_priority
FROM system_health_overview
`

// Get system health overview from view
func (q *Queries) GetSystemHealthOverview(ctx context.Context) ([]SystemHealthOverview, error) {
	rows, err := q.query(ctx, q.getSystemHealthOverviewStmt, getSystemHealthOverview)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SystemHealthOverview{}
	for rows.Next() {
		var i SystemHealthOverview
		if err := rows.Scan(
			&i.Component,
			&i.Status,
			&i.Details,
			&i.LastCheck,
			&i.StatusPriority,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopMetricsByValue = `-- name: GetTopMetricsByValue :many
SELECT 
    metric_name, component, value, timestamp
FROM metrics_data 
WHERE metric_type = ?
  AND timestamp >= ?
ORDER BY value DESC
LIMIT ?
`

type GetTopMetricsByValueParams struct {
	MetricType string    `json:"metric_type"`
	Timestamp  time.Time `json:"timestamp"`
	Limit      int64     `json:"limit"`
}

type GetTopMetricsByValueRow struct {
	MetricName string         `json:"metric_name"`
	Component  sql.NullString `json:"component"`
	Value      float64        `json:"value"`
	Timestamp  time.Time      `json:"timestamp"`
}

// Get top metrics by value for a specific metric type
func (q *Queries) GetTopMetricsByValue(ctx context.Context, arg GetTopMetricsByValueParams) ([]GetTopMetricsByValueRow, error) {
	rows, err := q.query(ctx, q.getTopMetricsByValueStmt, getTopMetricsByValue, arg.MetricType, arg.Timestamp, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopMetricsByValueRow{}
	for rows.Next() {
		var i GetTopMetricsByValueRow
		if err := rows.Scan(
			&i.MetricName,
			&i.Component,
			&i.Value,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertMetricData = `-- name: InsertMetricData :exec

INSERT INTO metrics_data (
    metric_name, metric_type, value, unit, session_id, component, tags, timestamp
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?
)
`

type InsertMetricDataParams struct {
	MetricName string         `json:"metric_name"`
	MetricType string         `json:"metric_type"`
	Value      float64        `json:"value"`
	Unit       sql.NullString `json:"unit"`
	SessionID  sql.NullString `json:"session_id"`
	Component  sql.NullString `json:"component"`
	Tags       sql.NullString `json:"tags"`
	Timestamp  time.Time      `json:"timestamp"`
}

// Telemetry and Metrics SQL Queries
// Insert a new metric data point
func (q *Queries) InsertMetricData(ctx context.Context, arg InsertMetricDataParams) error {
	_, err := q.exec(ctx, q.insertMetricDataStmt, insertMetricData,
		arg.MetricName,
		arg.MetricType,
		arg.Value,
		arg.Unit,
		arg.SessionID,
		arg.Component,
		arg.Tags,
		arg.Timestamp,
	)
	return err
}

const insertMetricMetadata = `-- name: InsertMetricMetadata :exec
INSERT INTO metrics_metadata (
    metric_name, metric_type, description, unit, component, enabled, retention_days
) VALUES (
    ?, ?, ?, ?, ?, ?, ?
) ON CONFLICT(metric_name) DO UPDATE SET
    metric_type = excluded.metric_type,
    description = excluded.description,
    unit = excluded.unit,
    component = excluded.component,
    enabled = excluded.enabled,
    retention_days = excluded.retention_days,
    updated_at = CURRENT_TIMESTAMP
`

type InsertMetricMetadataParams struct {
	MetricName    string         `json:"metric_name"`
	MetricType    string         `json:"metric_type"`
	Description   sql.NullString `json:"description"`
	Unit          sql.NullString `json:"unit"`
	Component     sql.NullString `json:"component"`
	Enabled       sql.NullBool   `json:"enabled"`
	RetentionDays sql.NullInt64  `json:"retention_days"`
}

// Insert or update metric metadata
func (q *Queries) InsertMetricMetadata(ctx context.Context, arg InsertMetricMetadataParams) error {
	_, err := q.exec(ctx, q.insertMetricMetadataStmt, insertMetricMetadata,
		arg.MetricName,
		arg.MetricType,
		arg.Description,
		arg.Unit,
		arg.Component,
		arg.Enabled,
		arg.RetentionDays,
	)
	return err
}

const insertPerformanceAlert = `-- name: InsertPerformanceAlert :one
INSERT INTO performance_alerts (
    alert_type, metric_name, current_value, threshold_value, severity,
    message, component, session_id
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?
) RETURNING id
`

type InsertPerformanceAlertParams struct {
	AlertType      string          `json:"alert_type"`
	MetricName     string          `json:"metric_name"`
	CurrentValue   sql.NullFloat64 `json:"current_value"`
	ThresholdValue sql.NullFloat64 `json:"threshold_value"`
	Severity       string          `json:"severity"`
	Message        string          `json:"message"`
	Component      sql.NullString  `json:"component"`
	SessionID      sql.NullString  `json:"session_id"`
}

// Insert a new performance alert
func (q *Queries) InsertPerformanceAlert(ctx context.Context, arg InsertPerformanceAlertParams) (int64, error) {
	row := q.queryRow(ctx, q.insertPerformanceAlertStmt, insertPerformanceAlert,
		arg.AlertType,
		arg.MetricName,
		arg.CurrentValue,
		arg.ThresholdValue,
		arg.Severity,
		arg.Message,
		arg.Component,
		arg.SessionID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertPerformanceBenchmark = `-- name: InsertPerformanceBenchmark :exec
INSERT INTO performance_benchmarks (
    metric_name, target_value, threshold_warning, threshold_critical, 
    unit, description, active
) VALUES (
    ?, ?, ?, ?, ?, ?, ?
) ON CONFLICT(metric_name) DO UPDATE SET
    target_value = excluded.target_value,
    threshold_warning = excluded.threshold_warning,
    threshold_critical = excluded.threshold_critical,
    unit = excluded.unit,
    description = excluded.description,
    active = excluded.active,
    updated_at = CURRENT_TIMESTAMP
`

type InsertPerformanceBenchmarkParams struct {
	MetricName        string          `json:"metric_name"`
	TargetValue       float64         `json:"target_value"`
	ThresholdWarning  sql.NullFloat64 `json:"threshold_warning"`
	ThresholdCritical sql.NullFloat64 `json:"threshold_critical"`
	Unit              sql.NullString  `json:"unit"`
	Description       sql.NullString  `json:"description"`
	Active            sql.NullBool    `json:"active"`
}

// Insert a performance benchmark
func (q *Queries) InsertPerformanceBenchmark(ctx context.Context, arg InsertPerformanceBenchmarkParams) error {
	_, err := q.exec(ctx, q.insertPerformanceBenchmarkStmt, insertPerformanceBenchmark,
		arg.MetricName,
		arg.TargetValue,
		arg.ThresholdWarning,
		arg.ThresholdCritical,
		arg.Unit,
		arg.Description,
		arg.Active,
	)
	return err
}

const resolveAlert = `-- name: ResolveAlert :exec
UPDATE performance_alerts 
SET resolved = TRUE, resolved_at = CURRENT_TIMESTAMP
WHERE id = ?
`

// Mark an alert as resolved
func (q *Queries) ResolveAlert(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.resolveAlertStmt, resolveAlert, id)
	return err
}

const updateMetricEnabled = `-- name: UpdateMetricEnabled :exec
UPDATE metrics_metadata 
SET enabled = ?, updated_at = CURRENT_TIMESTAMP 
WHERE metric_name = ?
`

type UpdateMetricEnabledParams struct {
	Enabled    sql.NullBool `json:"enabled"`
	MetricName string       `json:"metric_name"`
}

// Enable or disable a metric
func (q *Queries) UpdateMetricEnabled(ctx context.Context, arg UpdateMetricEnabledParams) error {
	_, err := q.exec(ctx, q.updateMetricEnabledStmt, updateMetricEnabled, arg.Enabled, arg.MetricName)
	return err
}

const updateSystemHealthStatus = `-- name: UpdateSystemHealthStatus :exec
INSERT INTO system_health (
    component, status, details, last_check
) VALUES (
    ?, ?, ?, ?
) ON CONFLICT(component) DO UPDATE SET
    status = excluded.status,
    details = excluded.details,
    last_check = excluded.last_check,
    updated_at = CURRENT_TIMESTAMP
`

type UpdateSystemHealthStatusParams struct {
	Component string         `json:"component"`
	Status    string         `json:"status"`
	Details   sql.NullString `json:"details"`
	LastCheck time.Time      `json:"last_check"`
}

// Update system health status for a component
func (q *Queries) UpdateSystemHealthStatus(ctx context.Context, arg UpdateSystemHealthStatusParams) error {
	_, err := q.exec(ctx, q.updateSystemHealthStatusStmt, updateSystemHealthStatus,
		arg.Component,
		arg.Status,
		arg.Details,
		arg.LastCheck,
	)
	return err
}
